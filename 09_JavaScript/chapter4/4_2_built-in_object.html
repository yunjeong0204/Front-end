<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    // 2. 내장 객체(JS 기본 제공)
    // 자바스크립트 엔진에 내장되어 필요한 경우 생성하여 사용

    // 1) 날짜 정보 객체: 날짜와 시간에 대한 정보를 제공
    // 변수 = new Date();
    // 사용성이 떨어져서 다른 외부 라이브러리 사용을 추천

    // 오늘 날짜에 대한 정보를 가지고 있는 객체 생성
    const today = new Date();
    const nowYear = today.getFullYear();
    const nowMonth = today.getMonth(); //0~11까지 있어 현재 월보다 1 적게 나옴
    const nowDate = today.getDate();
    const nowDay = today.getDay(); //0~6까지 있어 일요일~토요일까지 있음 / 0-일요일

    document.write('<h1>오늘 날짜 정보</h1>')
    document.write('날짜 정보(기본 포맷): ' + today, '<br>');
    document.write('현재 연도: ' +nowYear, '<br>');
    document.write('현재 월: ' +nowMonth, '<br>');
    document.write('현재 일: ' +nowDate, '<br>');
    document.write('현재 요일: ' +nowDay, '<br>');


    // 특정 날짜 정보를 갖는 날짜 객체 생성
    // new Date(연, 월, 일, 시, 분, 초, 밀리초);
    // 변수 = new Date(연, 월 - 1, 일);
    // 변수 = new Date('연/월/일');
    // 변수 = new Date('연-월-일');
    const someDay = new Date(2023, 6, 11); //7월을 표현하려면 -1을 한 6을 써주어야함

    const theYear = someDay.getFullYear();
    const theMonth = someDay.getMonth(); 
    const theDate = someDay.getDate();
    const theDay = someDay.getDay(); 

    document.write('<h1>특정 날짜 정보</h1>')
    document.write('날짜 정보(기본 포맷): ' + someDay, '<br>');
    document.write('특정 연도: ' +theYear, '<br>');
    document.write('특정 월: ' +theMonth, '<br>');
    document.write('특정 일: ' +theDate, '<br>');
    document.write('특정 요일: ' +theDay, '<br>');


    // 특정 날짜까지 D-day 구하기
    // 특정 일 수(밀리초) = 특정 날짜 객체 시간 - 현재 날짜 객체 시간
    // 1초 = 1000ms
    // 1분(60초) = 1000 * 60ms
    // 1시간(60분) = 1000 * 60 * 60ms
    // 1일(24시간) = 1000 * 60 * 60 * 24ms

    const diffDate = someDay.getTime() - today.getTime();
    // getTime(): 1970년 1월 1일 0시 0분 0초로부터 시작해서 지금까지 몇 ms가 지났는지 

    const result = Math.ceil(diffDate / (1000 * 60 * 60 * 24)); //ceil - 반올림해줌
    document.write('<h1>오늘부터 종강까지 남은 날짜</h1>');
    document.write('D-day: '+result+ '일 남았습니다.');


    // 2) 수학 객체: 수학 관련 기능과 속성을 제공
    // 객체 생성을 하지 않고 사용 가능 => 정적(static)
    // Math.메소드명;
    // Math.속성명;
    document.write('<h1>수학 객체 사용</h1>')
    const maxNum = Math.max(10, 5, 8, 30); //최대값
    const minNum = Math.min(10, 5, 8, 30); //최소값
    document.write(maxNum, '<br>');
    document.write(minNum, '<br>');


    const num = 2.1234;
    const roundNum = Math.round(num); //소수점 첫째 자리 반올림
    const floorNum = Math.floor(num); //소수점 첫째 자리 내림
    const ceilNum = Math.ceil(num); //소수점 첫째 자리 올림

    document.write(roundNum, '<br>');
    document.write(floorNum, '<br>');
    document.write(ceilNum, '<br>');


    const randomNum = Math.random(); //0이상 1미만의 난수 발생(실수값)
    document.write(randomNum, '<br>');
    document.write(Math.PI, '<br>'); //파이값 주고 싶을 때
    // random()을 이용하여 특정 범위의 랜덤한 정수값 구하기
    document.write('<h1>1~10까지 랜덤한 정수값 구하기</h1>')
    // 0.0 <= Math.random() < 1.0 
    document.write(randomNum, '<br>');
    // 0.0 <= Math.random() * 10 < 10.0 (0이상 10미만의 랜덤한 실수값이 나옴 - 곱하기 10해줘서) 
    document.write(randomNum * 10, '<br>');
    // 0 <= Math.floor(Math.random() * 10) < 10 (0이상 10미만의 랜덤한 정수값 - floor내림 써줘서) 
    document.write(Math.floor(randomNum * 10), '<br>');
    // 1 <= Math.floor(Math.random() * 10) + 1 < 11 (1이상 10미만의 랜덤한 정수값 - +1을 해줘서) 
    document.write(Math.floor(randomNum * 10) + 1, '<br>');

    // 공식화: Math.floor(Math.random() * (최대값 - 최소값 +1)) + 최소값;


    //컴퓨터가 내려는 가위, 바위, 보 맞추기! 
    // document.write('<h1>컴퓨터가 내려는 가위, 바위, 보 맞추기</h1>')
    // const game = prompt('가위, 바위, 보 중 선택하세요', '가위');
    // let gameNum;

    // switch (game) {
    //   case '가위':
    //     gameNum = 1;
    //     break;

    //   case '바위':
    //     gameNum = 2;
    //     break;

    //   case '보':
    //     gameNum = 3;
    //     break;
    
    //   default:
    //     alert('잘못 작성하였습니다');
    //     location.reload();
    //     break;
    // }
    // 1~3 사이의 정수값 난수 발생

    // const com = Math.floor(Math.random() * 3) + 1;
    // document.write(`<img src = "images/math_img_${com}.jpg">`);

    // if (gameNum === com) {
    //   document.write('<img src = "images/game_1.jpg">');
    // } else{
    //   document.write('<img src = "images/game_2.jpg">');
    // }
    // document.write('<br>');
    

    // Quiz: 맞추는 게임이 아닌 가위, 바위, 보 게임으로 바꿔보기
    // document.write('<h1>가위, 바위, 보 게임</h1>');

    // 내가 낸 이미지 출력
    // document.write(`<img src = "images/math_img_${gameNum}.jpg">`);
    
    // 컴퓨터가 낸 이미지 출력 
    // document.write(`<img src = "images/math_img_${com}.jpg">`);

    // document.write('<br>');
    
    // gamenum, com의 차를 이용
    // 0이면 비김
    // 1 또는 -2면 이김
    // 그 외는 짐
      // const whoWin = gameNum - com;
      // if (whoWin === 0) {
      //   document.write('비겼다');
      // } else if (whoWin === 1 || whoWin === -2) {
      //   document.write('이겼다');
      // } else {
      //   document.write('졌다.');
      // }


      // 3) 배열 객체: 변수는 하나의 데이터만 저장 가능, 배열은 여러 개의 데이터를 순차적으로 하나의 저장소에 저장
      // 예: 학생 30명의 시험 점수를 저장하려면 30개의 변수가 필요한데, 배열을 이용하면 하나의 배열로 30개의 데이터 저장 가능

      // 배열 객체 생성 3가지 방식
      // 첫번째 방식
      // 변수 = new Array(값1, 값2, 값3); 

      // 두번째 방식
      // 변수 = new Array(); 
      // 변수[0] = 값1;
      // 변수[1] = 값2;
      // 변수[2] = 값3;

      // 세번째 방식
      // 변수 = [값1, 값2, 값3]; => 리터럴 방식

      // 배열에 접근하기
      // 배열의 인덱스는 0부터 시작
      // 변수[인덱스 번호]로 접근 가능

      // 배열에 저장된 값 출력하기(여러가지 방법이 존재)
      const arr = [30, '따르릉', true];

      document.write('<h1>배열값 가져오기 -1</h1>');
      document.write(arr[0], '<br>');
      document.write(arr[1], '<br>');
      document.write(arr[2], '<br>');

      document.write('<h1>배열값 가져오기 -2</h1>');
      for(let i = 0; i < arr.length; i++) { //인덱스는 0,1,2라 i는 3까지/ arr.elngth = 3이다.
        document.write(arr[i], '<br>');
      }

      document.write('<h1>배열값 가져오기 -3</h1>');
      for(const i in arr) {//Key값을 가져옴 
        document.write(arr[i], '<br>');
      }

      // (참고)
      // for..in 반복문은 배열이 아니라 객체와 함께 사용할 때 최적화되어 있어서 배열에 사용하면 객체에 사용하는 것 대비 10~100배 정도 느림
      // for..in 반복문의 속도가 대체로 빠른 편이기 때문에 문제가 되진 않지만, 이런 차이를 알고 적절히 사용
      // 보통 배열엔 되도록 for..in 쓰지 말 것을 권장!

      document.write('<h1>배열값 가져오기 -4</h1>');
       //오른쪽에 반복가능한 객체 넣어주기(arr)
      for(const el of arr ) {//Value 값을 가져옴(ES6차)
        document.write(el, '<br>');
      }

      document.write('<h1>배열값 가져오기 -5</h1>');
      //인덱스와 배열 함께 출력하기
      arr.forEach(function (el, index) { 
        document.write(index, ' ', el, '<br>')
      });


      // 배열 객체의 메소드(1)
      const arr1 = ['사당', '교대', '방배', '강남'];
      const arr2 = ['신사', '압구정', '옥수'];

      let resultArr = arr1.join('-'); //join- 배열의 값을 지정한 문자로 연결하여 하나의 문자열 반환
      console.log(resultArr);

      resultArr = arr1.concat(arr2); //concat- 2개의 배열을 하나의 배열로 결합하여 새로운 배열로 반환
      console.log(resultArr);

      resultArr = arr1.slice(1, 3); //slice- 지정된 시작과 끝 위치(포함 안 함) 구간만큼 잘라내서 새로운 배열로 반환
      // 1부터 3까지 자르는데 3은 포함XX 따라서 1, 2만 삭제된 것
      console.log(resultArr);

      arr1.sort(); // 배열의 값을 오름차순(알파벳 순)으로 정렬
      console.log(arr1);

      arr2.reverse(); //배열의 순서를 반대로 바꿈(원본 배열이 변경됨)
      console.log(arr2);

      // (중요) array.sort(비교함수): 숫자를 정렬하기 위한 비교 함수 필요
      // 비교함수: function(a, b) {return a - b;}
      document.write('<h1>배열에서 숫자 데이터 정렬</h1>');
      const score = [40, 100, 1, 5, 25, 10];
      document.write(score.sort(), '<br>'); //'25'는 '100'보다 크다. 왜냐 '2'가 '1'보다 크기 때문
      document.write(score.sort(function(a, b) { return a - b; }), '<br>'); //'25'는 '100'보다 크다. 왜냐 '2'가 '1'보다 크기 때문
      //반환되는 값이 음수, 양수, 0인지에 따라 정렬이 바뀜 
      // 음수가 나오면 a, b순으로
      // 양수가 나오면 b, a순으로
      // 0이 나오면 변화 없음

      // 내림차순
      document.write(score.sort(function(a, b) { return b - a; }), '<br>'); 


      // 배열 객체의 메소드(2)
      const greenArr = ['교대', '방배', '강남'];
      const yellowArr = ['미금', '정자', '수서'];

      //splice 사용법 : array.splice(index, howmany, item1, ....., itemX) 
      greenArr.splice(2, 1, '서초', '역삼'); //splice- 배열 요소를 추가하거나 제거할 때 사용(원본 배열이 변경됨)
      // 강남이 제거되고 서초, 역삼이 추가됨
      console.log(greenArr);

      const popData = yellowArr.pop(); //pop- 배열의 마지막 요소(수서)를 제거, 제거된 요소를 반환(원본 배열이 변경됨)
      console.log(yellowArr);
      console.log(popData);

      const shiftData = yellowArr.shift(); //shift- 배열의 첫번째 요소(미금)를 제거, 제거된 요소를 반환(원본 배열이 변경됨)
      console.log(yellowArr);
      console.log(shiftData);

      yellowArr.push(shiftData); //push- 배열의 끝에 새 요소를 추가(원본 배열이 변경됨)
      console.log(yellowArr);
      yellowArr.unshift(popData); //unshift- 배열의 시작 부분에 새 요소를 추가(원본 배열이 변경됨)
      console.log(yellowArr);


      // 배열 객체의 메소드(3) - 검색 
      const fruits = ['Banana', 'Orange', 'Apple', 'Mango', 'Apple'];
      // indexOf(): 지정된 값의 첫번째 인덱스(위치)를 반환, 찾을 수 없는 경우 -1
      let index = fruits.indexOf('Apple'); 
      console.log(index); //2번째에 있는 apple 찾아서 결과 2가 뜸
      index = fruits.indexOf('Apple', 3); //검색 시작 위치 지정
      console.log(index); //결과 4라고 나옴

      // includes(): 지정된 값이 포함된 경우 true, 포함되지 않은 경우 false(ES7차)
      console.log(fruits.includes('Mango')); //Mango가 있어 true라고 나옴
      console.log(fruits.includes('Banana', 3)); //검색 시작 위치 지정(3이 시작 위치로 부터 banana가 있냐 - 없어서 false가 나옴) 




  </script>
</head>
<body>
  
</body>
</html>